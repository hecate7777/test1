<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>아이폰 벨소리 테스트</title>
</head>
<body>
  <h1>mp4 화일 30초 컷 & 3초 페이드아웃 다운로드 1</h1><hr>
  
  <h3>원하는 음악을 선택하세요.</h3>
  <h4><input type = "radio" name="bell" value="bts butter">bts butter</h4>
  <h4><input type = "radio" name="bell" value="He Makes Me Laugh">He Makes Me Laugh</h4>
  <h4><input type = "radio" name="bell" value="Here I am">Here I am</h4>
  <h4><input type = "radio" name="bell" value="밝게 빛나는 별이 되어 비춰줄게">밝게 빛나는 별이 되어 비춰줄게</h4>
  <h4><input type = "radio" name="bell" value="트리플에스">트리플에스</h4>
  <h3 id="bellselect"></h3>
  <hr>
  
  <audio id="myAudio" src="bts butter.mp4"></audio>
  <button onclick="cutAndFadeOutAudio(30, 3)"><h2>mp4 화일을 변형<br>(30초 컷, 3초 페이드아웃)</h2></button>
  <br>
  <h4 id="percentage"></h4><br><br>
  <button onclick="download()"><h2>mp4->m4r 다운로드</h2></button>
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.2/axios.min.js">
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const bellselect = document.querySelector('#bellselect')
      const myaudio = document.querySelector('#myAudio')
      const radios = document.querySelectorAll('[name=bell]')
      
      radios.forEach((radio) => {
        radio.addEventListener('change', (event) => {
          const current = event.currentTarget
          if (current.checked) {
            bellselect.textContent = `선택한 곡은 "${current.value}" 입니다.`
            myaudio.src = current.value + '.mp4'
          }
        })
      })
    })
    
/*
    function cutAndSave(cut_time, fadeout_time) {
      const audio = document.getElementById("audio");
      const ctx = new AudioContext();
      const source = ctx.createMediaElementSource(audio);
      const gainNode = ctx.createGain();
      source.connect(gainNode);
      gainNode.connect(ctx.destination);
      audio.play();
  
      setTimeout(() => {
        gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 3);
      }, (cut_time-fadeout_time) * 1000);
  
      setTimeout(() => {
        audio.pause();
        const blob = new Blob([audio.buffered], { type: "audio/mp3" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "cut-music.mp3";
        link.click();
      }, cut_time * 1000);
    }
*/
    
    function cutAndFadeOutAudio(cut_time, fadeout_time) {
      // 필요한 변수 정의
      const audioCtx = new AudioContext();
      const fadeTime = fadeout_time; // 페이드 아웃 시간 (초)
      const startTime = 0; // 자를 오디오의 시작 시간 (초)
      const endTime = cut_time; // 자를 오디오의 종료 시간 (초)
      const myaudio = document.querySelector('#myAudio')
      const audioFile = myaudio.src;

      // 오디오 파일 로드
      const audioRequest = new XMLHttpRequest();
      audioRequest.open('GET', audioFile, true);
      audioRequest.responseType = 'arraybuffer';
      audioRequest.onload = () => {
        // 로드 완료 후 버퍼 생성
        audioCtx.decodeAudioData(audioRequest.response, (buffer) => {
          // 오디오 버퍼를 새로운 버퍼로 자르기
          const source = audioCtx.createBufferSource();
          const newBuffer = audioCtx.createBuffer(buffer.numberOfChannels, (endTime - startTime) * buffer.sampleRate, buffer.sampleRate);
          for (let i = 0; i < buffer.numberOfChannels; i++) {
            const channelData = buffer.getChannelData(i).subarray(startTime * buffer.sampleRate, endTime * buffer.sampleRate);
            newBuffer.copyToChannel(channelData, i);
          }
          source.buffer = newBuffer;

          // 페이드 아웃 처리
          const gainNode = audioCtx.createGain();
          source.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          const fadeOutTime = source.buffer.duration - fadeTime;
          const fadeOutDuration = fadeTime * source.buffer.sampleRate;
          const currentGain = gainNode.gain.value;
          const fadeOut = (currentTime) => {
            const timeLeft = fadeOutTime - currentTime;
            if (timeLeft < fadeTime) {
              gainNode.gain.setValueAtTime(currentGain * timeLeft / fadeTime, currentTime);
            }
            if (currentTime + fadeOutDuration < audioCtx.currentTime) {
              source.stop();
            } else {
              requestAnimationFrame(fadeOut);
            }
          };
          source.start(0);
          requestAnimationFrame(fadeOut);

          // 새로운 오디오 파일 다운로드
          const newAudioFile =audioFile; // 저장할 새로운 오디오 파일 경로
          const audioBlob = new Blob([newBuffer], { type: 'audio/mp3' });
          const audioUrl = URL.createObjectURL(audioBlob);
          const downloadLink = document.createElement('a');
          downloadLink.href = audioUrl;
          downloadLink.download = newAudioFile;
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
        });
      };
      audioRequest.send();
    }

    function cutAndFadeOutAudio2(cut_time, fadeout_time) {
      const audioContext = new AudioContext();
      const myaudio = document.querySelector('#myAudio')
      const audioFile = myaudio.src;
      const audioElement = new Audio(audioFile);
      const sourceNode = audioContext.createMediaElementSource(audioElement);
      const gainNode = audioContext.createGain();
      const fadeDuration = fadeout_time;
      const bellselect = document.querySelector('#bellselect')

      sourceNode.connect(gainNode);
      gainNode.connect(audioContext.destination);

      audioElement.addEventListener("canplaythrough", function() {
        const startTime = audioContext.currentTime;
        const endTime = startTime + cut_time;

        // Set the gain to 1.0 at the start time
        gainNode.gain.setValueAtTime(1.0, startTime);

        // Fade out over the specified duration
        gainNode.gain.linearRampToValueAtTime(0.0, endTime - fadeDuration);

        // Stop the audio playback after the fade out has completed
        audioElement.addEventListener("ended", function() {
          audioElement.pause();
          audioElement.currentTime = 0;
        });
        
        setTimeout(function() {
          audioElement.pause();
          
          const blob = new Blob([audioElement.buffered], { type: "audio/mp4" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
     alert(document.querySelector('input[name="bell"]:checked').value+'.mp4')
          link.setAttribute('download', document.querySelector('input[name="bell"]:checked').value+'.mp4');
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }, (endTime - startTime - fadeDuration) * 1000);

        // Start the audio playback and wait for the fade out to complete
        audioElement.play();
      });
    }
    
    function cutAndSave_old(cut_time, fadeout_time) {
      const audio = document.getElementById('myAudio');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      const startTime = audio.currentTime;
      const endTime = startTime + cut_time;

      audio.currentTime = startTime;
      audio.play();

      audio.addEventListener('timeupdate', function () {
        if (audio.currentTime >= endTime) {
          audio.pause();
          canvas.width = audio.width;
          canvas.height = audio.height;
          ctx.drawImage(audio, 0, 0, audio.width, audio.height);

alert("6")
          const fadeOutStart = audio.duration - fadeout_time;
          const fadeOutEnd = audio.duration;
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

alert("7")
          for (let i = 0; i < imageData.data.length; i += 4) {
            const alpha = (audio.currentTime > fadeOutStart)
              ? 1 - ((audio.currentTime - fadeOutStart) / (fadeOutEnd - fadeOutStart))
              : 1;
            imageData.data[i + 3] = Math.floor(alpha * 255);
          }

          ctx.putImageData(imageData, 0, 0);

          const newAudio = new Audio();
          const newBlob = canvasToBlob(canvas);
          const newUrl = URL.createObjectURL(newBlob);

alert(newUrl)
        
          newAudio.src = newUrl;
          newAudio.controls = true;
          document.body.appendChild(newAudio);
        }
      });
    }
    
    function canvasToBlob(canvas) {
      return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          if (blob) {
            resolve(blob);
          } else {
            reject();
          }
        }, 'audio/mp4', 1);
      });
    }
    
    function download() {
      axios({
        url: '트리플에스.mp4',
        method: 'GET',
        responseType: 'blob'
      })
      .then((response) => {
        const url = window.URL
        .createObjectURL(new Blob([response.data]));
        const link = document.createElement('a');
        link.href = url;
        link.setAttribute('download', 'tripleS.m4r');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      })
    }
  </script>
</body>
</html>


